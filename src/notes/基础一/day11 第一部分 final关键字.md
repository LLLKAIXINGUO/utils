# day11 第一部分 final关键字

final 关键字代表最终、不可改变的

常见的四种用法：

1. 可以用来修饰一个类【表示类不可被继承】

2. 可以用来修饰一个方法【表示方法不可被重写】

3. 可以用来修饰一个局部变量【表示变量不可被更改， “一次赋值，终身不变”】     对于基本数据类型来说，不可变说的是变量中的数据不可改变

   ​             对于引用类型来说，不可变说的是变量当中的地址值不可改变

4. 可以用来修饰要给成员变量  【表示变量不可变，由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了】【对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。 ==二者选其一==】

**注意：**一个类如果是final的，那么其中所有的成员方法都不可以被覆盖重写

**注意：**对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。





**内部类：**如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。 eg:身体和心脏的关系         eg:汽车和发动机的关系

**分类：**

1. 成员内部类                               **成员内部类的定义格式：**     

   ```java
   修饰符   class  外部类名称{
       修饰符  class  内部类名称{
           //.....
       }
   }
   注意：内用外，随意访问；外用内，需要内部类对象
   ```

   **如何使用成员内部类？ 内部类的使用的两种方式**

   * 1.间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。
   * 2.直接方法：  公式： 外部类名称.内部类名称  对象名  =  new  外部类名称（）.new  内部类名称（）；

2. 局部内部类（包含匿名内部类）

   **定义格式：**

   ```java
   修饰符  class 外部类名称{
   
   ​		修饰符  返回值类型  外部类方法名称（参数列表）{
   
   ​				class 局部内部类名称{
   
   ​						//.......
   
          }
   
      }
   
   }
   ```

   **定义一个类的时候，权限修饰符规则：**

   1. 外部类：public / (default)
   2. 成员内部类：public / protexted / (default) / private
   3. 局部内部类：什么都不写

==局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】==

**原因：**

1. new 出来的对象在堆内存当中
2. 局部变量是跟着方法走的，在栈内存当中
3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失
4. new出来的对象会在堆当中持续存在，直到垃圾回收消失

  

* 重要   **匿名内部类**
* 使用匿名内部类的 场景：如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。

**匿名内部类的定义格式：**

接口名称  对象名  =  new  接口名称（）{

​			//覆盖重写所有抽象方法

};

对“new 接口名称（）{.....}"格式进行解析： 

1. new代表创建对象的动作       
2. 接口名称就是匿名内部类需要实现哪个接口
3. {...}这才是内部类的内容

**注意的问题：**

1. 匿名内部类在创建对象时，只能使用唯一一次
2. 如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。



可以使用自定义类 或 接口作为成员变量



**使用接口作为方法的参数 或者返回值**

