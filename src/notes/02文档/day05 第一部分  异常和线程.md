# day05 第一部分  异常和线程

## **异常：**

#### 指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止【在java等面向对象的编程语言中，异常本身也是一个类，产生异常就是创建异常对象并抛出一个异常对象。java处理异常的方式是中断处理】

==异常指的并不是语法错误，语法错了，不会产生字节码文件，根本不能运行==

![image-20210914143350602](C:\Users\19900\AppData\Roaming\Typora\typora-user-images\image-20210914143350602.png)

**Throwable体系：**

* **Error:**严重错误Error,无法通过处理的错误，只能事先避免，好比绝症
* **Exception:**表示异常，异常产生后，程序员可以通过代码的方式纠正，使得程序继续运行，是必须要处理的 。比如：感冒...

**异常的分类：**

* **Exception:**编译期异常，进行编译（写代码）java程序出现的问题
  * RuntimeException:运行期异常，java程序运行过程中出现的问题
  * 异常就相当于程序得了一个小毛病，把异常处理掉，程序可以继续运行
* **Error:**错误  就相当于程序得了一个无法治愈的毛病



**异常的处理：**

throw关键字

​		作用：可以使用throw关键字在指定的方法中抛出指定的异常

使用格式：

​		throw  new  xxxException("异常产生的原因");

**注意：**

1. throw  关键字必须写在方法的内部

2. throw关键字后边的new 的对象必须是Exception的子类对象

3. throw关键字抛出指定的异常对象，我们就必须处理这个异常对象

   ​	throw关键字后边创建的RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）；

   ​	throw关键字的后边创建的是编译异常（写代码的时候报错，）我们就必须处理这个异常，要么throws,要么try...catch....

在工作中，我们首先必须对方法传递过来的参数进行合法性校验

如果参数不合格，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题



**Objects非空判断：**

* public static <T> T requireNoNull(T obj):      查看指定引用对象不是null

**声明异常的关键字：throws关键字**     交给别人处理

**作用：**

​		当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象

​		可以使用throws关键字处理异常对象，会把异常对象生命抛出给方法调用者处理（自己不处理，给别人处理）最终交给JVM处理

**使用格式：**在方法声明时使用

​			修饰符    返回值类型       方法名（参数列表）  throws   AAAException，BBBException{

​							throw  new   AAAException("产生原因")；

​							throw  new   BBBException("产生原因")；

​			}

**注意：**

1. throws 关键字必须写在方法声明处

2. throws关键字后边声明的异常必须时Exception或者时Exception的子类

3. 方法内部如果抛出了多个异常对象，那么throws后边也必须声明多个异常

   如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可

4. 调用了一个声明抛出异常的方法，我们就必须的处理声明对象的异常

   要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM

   要么 try.....catch自己处理异常



**try...catch：异常处理的第二种方式，自己处理异常**

**格式：**

**try**{

​		可能产生异常的代码}**catch(定义一个异常的变量，用来接收try中抛出的异常)**{

异常的处理逻辑，异常对象之后，怎么处理异常对象

一般在工作中，会把异常的信息记录到一个日志中去}     **catch可以有多个**

**注意事项：**

1. try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象

2. 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码

   如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try...catch之后的代码



**Throwable类中定义了三个异常处理的方法**

* String   getMessage()     返回此  throwable的简短描述
* String  toString()           返回此throwable 的详细消息字符串
* void  printStackTrace()   JVM打印异常对象，默认此方法，打印的异常信息时最全面的



**finally**        无论是否出现异常，都会执行

**注意：**

1. finally  不能单独使用，必须和try一起使用
2. finally 一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放资源



**异常注意事项：**

多个异常使用捕获又该如何处理呢：？？？

1.  多个异常分别处理           try{} catch(){}  try{} catch(){}

2. 多个异常一次捕获，多次处理  try{} catch(){} catch(){} 【一般使用】

   **注意：** catch里边定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在上面，否则就会报错

3. 多个异常异常捕获，一次处理try{} catch(){}



**子父类的异常：**

* 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常
* 父类方法没有抛出异常，子类重写父类方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出

**注意：**  父类异常是什么样，子类异常什么样



**自定义异常：**

 				java提供的异常类，不够我们使用，需要自己定义一些异常类

**格式：**

```
public  class  XXXException     extends   Exception | RuntimeException{

​				添加空参数的构造方法

​				添加一个带异常信息的构造方法

}
```

**注意：**

1. 自定义异常类一般都是以Exception结尾，说明该类是一个异常类

2. 自定义异常类，必须的继承Exception或者RuntimeException

   ​	继承Exception :那么自定义的异常类就是一个编译异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try...catch

   ​	继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）

